% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpData.R
\name{interpData}
\alias{interpData}
\title{Interpolate a dataset}
\usage{
interpData(obj, new.Coordinates = list(x = NULL, y = NULL),
  method = c("nearest", "bilinear"), parallel = FALSE, max.ncores = 16,
  ncores = NULL)
}
\arguments{
\item{obj}{A data object coming from \code{loadGridData}, \code{loadStationData} of package \pkg{loadeR}, or the \pkg{loadeR.ECOMS} 
package function \code{loadECOMS}.}

\item{new.Coordinates}{Definition of the new coordinates (grid or locations), in the form of a list with the x and y components, in thir order.
Each component consists of a vector of length three with components \emph{from}, \emph{to} and \emph{by},
 in this order, similar as the arguments passed to the \code{\link[base]{seq}} function, giving the 
 westernmost, easternmost and grid cell width in the X axis and, in the same way,
 the southernmost, northernmost and grid cell resolution in the Y axis. See details.}

\item{method}{Method for interpolation. Currently implemented methods are either \code{"bilinear"},
for bilinear interpolation, and \code{"nearest"}, for nearest-neighbor interpolation (default).}

\item{parallel}{Logical. Should parallel execution be used?}

\item{max.ncores}{Integer. Upper bound for user-defined number of cores.}

\item{ncores}{Integer number of cores used in parallel computation. Self-selected number of
cores is used when \code{ncpus = NULL} (the default), or when \code{maxcores} exceeds the default \code{ncores} value.}
}
\value{
An interpolated object preserving the structure of the input
}
\description{
Interpolation of gridded datasets into a user-defined grid using nearest-neighbour or bilinear weights.
}
\details{
In case of default definition of either x, y or both grid coordinates, the default grid
is calculated taking the corners of the current grid and assuming x and y resolutions equal to 
the default \code{by} argument value in function \code{\link[base]{seq}}: \emph{by = ((to - from)/(length.out - 1))}.
The bilinear interpolator uses the \code{\link[akima]{interp}} algorithm. 
The output has special attributes in the \code{xyCoords} element that indicate that the object
 has been interpolated. These attributes are \code{interpolation}, which indicates the method used and
 \code{resX} and \code{resY}, for the grid-cell resolutions in the X and Y axes respectively.
 It is also possible to pass the interpolator the grid of a previously existing grid dataset using the
 \code{\link{getGrid}} method.
}
\note{
To avoid unnecessary NA values, the function will not extrapolate using a new grid outside the
current extent of the dataset, returning an error message.
}
\section{Parallel Processing}{


Parallel processing is enabled using the \pkg{parallel} package. 
Parallelization is undertaken by a FORK-type parallel socket cluster formed by \code{ncores}.
If \code{ncores} is not specified (default), \code{ncores} will be one less than the autodetected number of cores.
The maximum number of cores used for parallel processing can be set with the \code{max.ncores} argument, 
although this will be reset to the auto-detected number of cores minus 1 if this number is exceeded. Note that not all 
code, but just some critical loops within the function are parallelized.

In practice, parallelization does not always result in smaller execution times, due to the parallel overhead.
However, parallel computing may potentially provide a significant speedup for the 
particular case of large multimember datasets or large grids.
 
Parallel computing is currently not available for Windows machines.
}
\examples{
\dontrun{
# Load air temperature at 850 mb isobaric pressure level for boreal winter (DJF) 1991-2010
data(iberia_ncep_ta850)
par(mfrow = c(2,1))
plotMeanGrid(iberia_ncep_ta850)
# Bilinear interpolation to domain centered in Spain using a 0.5 degree resolution 
# in both X and Y axes
t <- interpData(iberia_ncep_ta850, new.Coordinates = list(x = c(-10,5,.5),
                                                          y = c(36,44,.5)),
                                   method = "bilinear")
plotMeanGrid(t)
par(mfrow=c(1,1))
# New attributes indicate that the data have been interpolated:
attributes(t$xyCoords)
}
}
\author{
J. Bedia, S. Herrera, M. de Felice
}

